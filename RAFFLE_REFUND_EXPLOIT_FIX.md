# üö® FIX CR√çTICO: EXPLOIT ECON√ìMICO EN REEMBOLSOS + ERROR SQL

**Fecha:** 2025-11-06 10:37am  
**Severidad:** CATASTR√ìFICA - Generaci√≥n Infinita de Fuegos  
**Reportado por:** Usuario (an√°lisis de reembolsos)

---

## PROBLEMA 1: EXPLOIT ECON√ìMICO - REEMBOLSO INCORRECTO

### Descripci√≥n del Exploit

El sistema permit√≠a **generar fuegos de la nada** al cancelar rifas con n√∫meros vendidos.

### Flujo INCORRECTO (Antes del Fix):

```
1. Usuario compra n√∫mero (10 üî•):
   - UPDATE wallets SET fires_balance = fires_balance - 10 (usuario)
   - UPDATE raffles SET pot_fires = pot_fires + 10 (rifa)

2. Rifa finaliza normalmente:
   - Host/Tote recibe pot_fires completo
   - Si 5 usuarios compraron: Tote recibe +50 üî•

3. Rifa CANCELADA (cancelRaffleWithRefund):
   - Admin pierde: -50 üî• (descuento de wallet admin)
   - Usuarios recuperan: +10 üî• cada uno (total +50 üî•)
   
   RESULTADO NETO:
   ‚úÖ Usuarios: +0 üî• (recuperan lo que pagaron)
   ‚úÖ Admin: -50 üî• (pierde la comisi√≥n que YA recibi√≥)
   ‚ùå Tote: +50 üî• (MANTIENE el dinero SIN devolverlo)
   
   ‚Üí DINERO DUPLICADO: +50 üî• generados de la nada
   ‚Üí Tote puede repetir esto infinitamente
```

### Flujo CORRECTO (Despu√©s del Fix):

```
1. Usuario compra n√∫mero (10 üî•):
   - UPDATE wallets SET fires_balance = fires_balance - 10 (usuario)
   - UPDATE raffles SET pot_fires = pot_fires + 10 (rifa)

2. Rifa CANCELADA:
   - HOST/Tote pierde: -50 üî• (devuelve pot_fires)
   - Usuarios recuperan: +10 üî• cada uno (total +50 üî•)
   - Admin: +0/-0 üî• (NO participa en este flujo)
   
   RESULTADO NETO:
   ‚úÖ Usuarios: +0 üî• (recuperan lo que pagaron)
   ‚úÖ Host: +0 üî• (pierde pot pero recupera platform_fee)
   ‚úÖ Admin: +0 üî• (devuelve platform_fee al host)
   
   ‚Üí SIN GENERACI√ìN DE DINERO
   ‚Üí Econom√≠a balanceada
```

---

## C√ìDIGO MODIFICADO

### Archivo: `backend/services/RaffleService.js`

**Funci√≥n:** `cancelRaffleWithRefund()` l√≠neas 1814-1846

#### ANTES (Incorrecto):
```javascript
// Solo reembolsaba a usuarios
for (const num of soldNumbers.rows) {
    await client.query(`
        UPDATE wallets 
        SET fires_balance = fires_balance + $1 
        WHERE user_id = $2
    `, [costPerNumber, num.owner_id]);
}

// Admin perd√≠a dinero m√°s adelante (l√≠neas 1840-1863)
await client.query(`
    UPDATE wallets 
    SET fires_balance = fires_balance - $1 
    WHERE user_id = $2
`, [platformFee, adminUserId]);
```

#### DESPU√âS (Correcto):
```javascript
// 1. DESCONTAR del HOST (que recibi√≥ el pot_fires)
if (totalRefundBuyers > 0) {
    await client.query(`
        UPDATE wallets 
        SET fires_balance = fires_balance - $1 
        WHERE user_id = $2
    `, [totalRefundBuyers, raffleData.host_id]);
    
    // Registrar transacci√≥n del host (devuelve lo recibido)
    await client.query(`
        INSERT INTO wallet_transactions 
        (wallet_id, type, currency, amount, ...)
        VALUES (...)
    `, [raffleData.host_id, totalRefundBuyers, ...]);
    
    logger.info('üí∏ Host devuelve pot_fires para reembolso', {
        hostId: raffleData.host_id,
        amount: totalRefundBuyers
    });
}

// 2. Reembolsar a cada comprador
for (const num of soldNumbers.rows) {
    await client.query(`
        UPDATE wallets 
        SET fires_balance = fires_balance + $1 
        WHERE user_id = $2
    `, [costPerNumber, num.owner_id]);
}
```

---

## PROBLEMA 2: ERROR SQL - COLUMNA `pot_fires` NO EXISTE

### Descripci√≥n del Error

```sql
Database query error: error: "column \"pot_fires\" does not exist"
query: "SELECT COALESCE(SUM(pot_fires), 0) FROM bingo_v2_rooms..."
```

### Causa Root

El c√≥digo intentaba acceder a columna `pot_fires` en tabla `bingo_v2_rooms`, pero la columna correcta es `total_pot`.

**Schema Real:**
```sql
CREATE TABLE bingo_v2_rooms (
  id SERIAL PRIMARY KEY,
  ...
  total_pot DECIMAL(10, 2) DEFAULT 0,  -- ‚úÖ COLUMNA CORRECTA
  ...
);
```

---

## C√ìDIGO MODIFICADO

### Archivo: `backend/routes/admin.js`

**Funci√≥n:** GET `/api/admin/stats` l√≠nea 381

#### ANTES (Incorrecto):
```javascript
const gameStats = await query(`
  SELECT 
    (SELECT COALESCE(SUM(pot_fires), 0) 
     FROM bingo_v2_rooms 
     WHERE status IN ('waiting', 'playing')) as total_bingo_pot_fires
`);
```

#### DESPU√âS (Correcto):
```javascript
const gameStats = await query(`
  SELECT 
    (SELECT COALESCE(SUM(total_pot), 0) 
     FROM bingo_v2_rooms 
     WHERE status IN ('waiting', 'in_progress')) as total_bingo_pot_fires
`);
```

**Cambios adicionales:**
- `pot_fires` ‚Üí `total_pot` (nombre correcto de columna)
- `'playing'` ‚Üí `'in_progress'` (status correcto seg√∫n schema)

---

## IMPACTO DE LOS BUGS

### Exploit Econ√≥mico:
- ‚úÖ **Usuarios afectados:** Todos los que compraron en rifas canceladas
- ‚úÖ **Dinero generado:** Desconocido (requiere auditor√≠a DB)
- ‚úÖ **Hosts beneficiados:** Recib√≠an fuegos sin devolverlos
- ‚úÖ **Admin afectado:** Perd√≠a fuegos que no deb√≠a perder

### Error SQL:
- ‚úÖ **Panel admin bloqueado:** Estad√≠sticas no cargaban
- ‚úÖ **Visibilidad reducida:** No se ve√≠a estado de juegos

---

## ARCHIVOS MODIFICADOS

1. **backend/services/RaffleService.js**
   - L√≠neas 1801-1868: Flujo de reembolso corregido
   - Agregado: Descuento de pot_fires del host
   - Agregado: Logging exhaustivo de reembolsos

2. **backend/routes/admin.js**
   - L√≠nea 381: pot_fires ‚Üí total_pot
   - L√≠nea 380: 'playing' ‚Üí 'in_progress'

3. **RAFFLE_REFUND_EXPLOIT_FIX.md** (este documento)

---

## LOGGING AGREGADO

### RaffleService.cancelRaffleWithRefund()

```javascript
logger.info('üîÑ Iniciando reembolso por cancelaci√≥n', {
    raffleId,
    raffleCode,
    totalBuyers,
    costPerNumber,
    totalRefundBuyers,
    potFires,
    hostId
});

logger.info('üí∏ Host devuelve pot_fires para reembolso', {
    hostId,
    amount: totalRefundBuyers
});

logger.info('üí∞ Platform fee descontado del admin', {
    adminUserId,
    platformFee,
    raffleCode
});
```

### Verificaci√≥n en Railway Logs:

```bash
# Buscar reembolsos:
grep "üîÑ Iniciando reembolso por cancelaci√≥n"

# Verificar descuento host:
grep "üí∏ Host devuelve pot_fires"

# Verificar devoluci√≥n platform_fee:
grep "üí∞ Platform fee descontado del admin"
```

---

## TESTING POST-DEPLOY

### 1. Crear Rifa Modo Fires
```bash
1. Usuario A crea rifa (costo creaci√≥n: 10 üî•)
2. Usuario B compra 5 n√∫meros (5 x 10 = 50 üî•)
3. pot_fires de la rifa = 50 üî•
```

### 2. Cancelar Rifa (Admin/Tote)
```bash
POST /api/raffles/{id}/cancel-refund
{
  "reason": "Testing reembolso corregido"
}
```

### 3. Verificar Wallets:

```sql
-- Usuario A (host):
-- Antes: perdi√≥ 10 üî• (platform_fee)
-- Despu√©s cancelaci√≥n: recupera 10 üî• (platform_fee)
-- PERO pierde 50 üî• (devuelve pot_fires)
-- Neto: -50 üî•

-- Usuario B (comprador):
-- Antes: perdi√≥ 50 üî•
-- Despu√©s: recupera 50 üî•
-- Neto: +0 üî•

-- Admin:
-- Antes: gan√≥ 10 üî• (platform_fee)
-- Despu√©s: pierde 10 üî• (devuelve platform_fee)
-- Neto: +0 üî•

-- TOTAL SISTEMA: +0 üî• (SIN GENERACI√ìN)
```

### 4. Verificar Transacciones:

```sql
SELECT * FROM wallet_transactions 
WHERE type IN ('raffle_refund_from_pot', 'raffle_number_refund', 'raffle_refund_platform_fee')
ORDER BY created_at DESC;
```

---

## AUDITOR√çA REQUERIDA

### Detectar Rifas Canceladas con Exploit:

```sql
-- Rifas canceladas con n√∫meros vendidos (posible exploit)
SELECT 
  r.id,
  r.code,
  r.host_id,
  r.pot_fires,
  COUNT(rn.id) as sold_numbers,
  r.created_at,
  r.ended_at
FROM raffles r
JOIN raffle_numbers rn ON r.id = rn.raffle_id
WHERE r.status = 'cancelled'
  AND rn.state = 'sold'
  AND r.ended_at > '2025-10-01'
GROUP BY r.id
ORDER BY r.ended_at DESC;
```

### Calcular Fuegos Generados por Exploit:

```sql
-- Suma de pot_fires que NO se devolvieron en rifas canceladas
SELECT 
  SUM(r.pot_fires) as total_exploit_fires,
  COUNT(DISTINCT r.id) as affected_raffles,
  COUNT(DISTINCT r.host_id) as benefited_hosts
FROM raffles r
JOIN raffle_numbers rn ON r.id = rn.raffle_id
WHERE r.status = 'cancelled'
  AND rn.state = 'sold'
  AND r.pot_fires > 0
  AND r.ended_at > '2025-10-01';
```

### Hosts que se Beneficiaron:

```sql
SELECT 
  u.username,
  u.tg_id,
  COUNT(r.id) as cancelled_raffles,
  SUM(r.pot_fires) as total_kept_fires
FROM users u
JOIN raffles r ON r.host_id = u.id
WHERE r.status = 'cancelled'
  AND r.pot_fires > 0
GROUP BY u.id
ORDER BY total_kept_fires DESC;
```

---

## MITIGACI√ìN

### Si se detecta exploit masivo:

1. **Rollback manual de fuegos:**
```sql
-- Para cada host identificado:
UPDATE wallets 
SET fires_balance = fires_balance - <monto_exploit>
WHERE user_id = <host_id>;

-- Registrar transacci√≥n:
INSERT INTO wallet_transactions (...) 
VALUES (..., 'admin_correction_exploit', ...);
```

2. **Notificaci√≥n a usuarios afectados**
3. **Reporte p√∫blico de transparencia**

---

## COMMIT

**Hash:** (Pendiente)
**Mensaje:** `fix CATASTR√ìFICO: exploit econ√≥mico reembolsos rifas + error SQL pot_fires`

**Archivos:**
- backend/services/RaffleService.js
- backend/routes/admin.js
- RAFFLE_REFUND_EXPLOIT_FIX.md

---

## LECCIONES APRENDIDAS

1. **Reembolsos deben salir del beneficiario original**
   - NO del admin
   - NO del max supply
   - S√ç del que recibi√≥ el dinero

2. **Logging exhaustivo en operaciones financieras**
   - Permite detectar exploits r√°pidamente
   - Facilita auditor√≠as

3. **Testing de flujos econ√≥micos completos**
   - Crear ‚Üí Comprar ‚Üí Cancelar
   - Verificar balance neto = 0

4. **Verificar nombres de columnas contra schema real**
   - No asumir basado en c√≥digo
   - Consultar DATABASE_SCHEMA_MASTER.sql

---

**Status:** ‚úÖ HOTFIX APLICADO  
**Deploy:** Pendiente (6 minutos)  
**Auditor√≠a:** URGENTE REQUERIDA
