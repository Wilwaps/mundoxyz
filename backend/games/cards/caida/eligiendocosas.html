<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Elegir cosas – lienzo de elementos</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    }

    .wrap {
      flex: 1;
      display: flex;
      flex-direction: row;
      align-items: stretch;
      justify-content: stretch;
      padding: 16px;
      gap: 16px;
      max-width: none;
    }

    .sidebar {
      width: 320px;
      max-width: 360px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    h1 {
      font-size: 20px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #cbd5f5;
    }

    .toolbar {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      gap: 10px;
    }

    .btn-primary {
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(34,197,94,0.9);
      background: radial-gradient(circle at 30% 0%, #22c55e, #15803d 60%, #052e16 100%);
      color: #ecfdf5;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(15,23,42,0.9),
        0 10px 24px rgba(0,0,0,0.7);
    }

    .btn-primary:hover {
      filter: brightness(1.07);
    }

    .selected-info {
      font-size: 13px;
      color: #e5e7eb;
      opacity: 0.9;
    }

    .canvas-frame {
      flex: 1;
      border-radius: 18px;
      padding: 18px;
      background:
        radial-gradient(circle at top, #020617, #000 70%);
      box-shadow:
        0 18px 40px rgba(0,0,0,0.9),
        inset 0 0 0 1px rgba(30,64,175,0.6);
      display: flex;
    }

    .canvas {
      position: relative;
      flex: 1;
      border-radius: 14px;
      background:
        radial-gradient(circle at 20% 0%, #1e293b, #020617 60%, #000 100%);
      overflow: hidden;
      box-shadow:
        inset 0 0 0 1px rgba(15,23,42,0.9),
        0 10px 30px rgba(0,0,0,0.8);
      cursor: crosshair;
      min-height: 400px;
    }

    .shape {
      position: absolute;
      border-radius: 16px;
      background: #ef4444;
      box-shadow:
        0 0 0 1px rgba(15,23,42,0.95),
        0 10px 22px rgba(0,0,0,0.8);
      cursor: grab;
      transition: box-shadow 0.12s ease-out, transform 0.12s ease-out;
    }

    .shape::before {
      content: "";
      position: absolute;
      inset: 0;
      border: 2px solid #e5e7eb;
      border-radius: inherit;
      pointer-events: none;
      clip-path: inherit;
    }

    .shape.is-selected::before {
      border-color: #22c55e;
      box-shadow:
        0 0 0 1px rgba(34,197,94,0.8),
        0 0 18px rgba(34,197,94,0.7);
    }

    .dimensions {
      margin-top: 10px;
      font-size: 13px;
      color: #e5e7eb;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.5);
      display: inline-flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .dimensions span strong {
      color: #a5f3fc;
    }

    .panel {
      margin-top: 18px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }

    .panel label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #020617;
      border-radius: 10px;
      padding: 8px 12px;
      border: 1px solid rgba(55,65,81,0.9);
      font-size: 13px;
      color: #e5e7eb;
    }

    .panel input[type="range"] {
      width: 170px;
      accent-color: #22c55e;
    }

    .panel input[type="color"] {
      width: 40px;
      height: 24px;
      padding: 0;
      border: none;
      background: transparent;
      cursor: pointer;
    }

    .panel select {
      font-size: 13px;
      background: #020617;
      color: #e5e7eb;
      border-radius: 6px;
      border: 1px solid rgba(55,65,81,0.9);
      padding: 4px 8px;
    }

    .shape .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #fbbf24;
      border: 1px solid #111827;
      border-radius: 2px;
      box-shadow: 0 0 0 1px rgba(15,23,42,0.9);
    }

    .shape .resize-nw {
      top: 0;
      left: 0;
      transform: translate(-50%, -50%);
      cursor: nwse-resize;
    }

    .shape .resize-ne {
      top: 0;
      right: 0;
      transform: translate(50%, -50%);
      cursor: nesw-resize;
    }

    .shape .resize-se {
      bottom: 0;
      right: 0;
      transform: translate(50%, 50%);
      cursor: nwse-resize;
    }

    .shape .resize-sw {
      bottom: 0;
      left: 0;
      transform: translate(-50%, 50%);
      cursor: nesw-resize;
    }

    .vertex-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #22c55e;
      border: 1px solid #022c22;
      box-shadow: 0 0 0 1px rgba(15,23,42,0.9);
      transform: translate(-50%, -50%);
      cursor: pointer;
      z-index: 40;
    }

    .shape-text {
      position: absolute;
      inset: 6px;
      padding: 4px 6px;
      color: #f9fafb;
      font-size: 13px;
      line-height: 1.3;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      pointer-events: auto;
      overflow: hidden;
      white-space: pre-wrap;
    }

    .ai-figures-tool {
      margin-top: 10px;
      align-items: stretch;
    }

    .ai-figures-input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(55,65,81,0.9);
      background: #020617;
      color: #e5e7eb;
      font-family: inherit;
      font-size: 13px;
      resize: vertical;
      min-height: 40px;
    }

    .ai-figures-button {
      margin-top: 4px;
    }

    .ai-figures-status {
      font-size: 12px;
      color: #9ca3af;
      min-height: 16px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="sidebar">
      <h1>Lienzo de elementos</h1>

      <div class="toolbar">
        <button class="btn-primary" id="addElement">+ elemento</button>
        <button class="btn-primary" id="toggleText">Texto</button>
        <button class="btn-primary" id="exportPng">Exportar PNG</button>
        <button class="btn-primary" id="exportHtml">Exportar HTML</button>
        <span class="selected-info" id="selectedInfo">Sin elemento seleccionado</span>
      </div>

      <div class="dimensions" id="dims">
        <span><strong>X:</strong> <span id="dim-x">-</span> px</span>
        <span><strong>Y:</strong> <span id="dim-y">-</span> px</span>
        <span><strong>Ancho:</strong> <span id="dim-w">-</span> px</span>
        <span><strong>Alto:</strong> <span id="dim-h">-</span> px</span>
        <span><strong>Rotación:</strong> <span id="dim-rot">-</span> °</span>
      </div>

      <div class="panel">
        <label>
          Posición X (px)
          <input type="range" id="posX" min="0" max="800" value="0" />
        </label>
        <label>
          Posición Y (px)
          <input type="range" id="posY" min="0" max="400" value="0" />
        </label>
        <label>
          Ancho (px)
          <input type="range" id="sizeW" min="30" max="400" value="120" />
        </label>
        <label>
          Alto (px)
          <input type="range" id="sizeH" min="30" max="400" value="80" />
        </label>
        <label>
          Rotación (°)
          <input type="range" id="rotate" min="0" max="360" value="0" />
        </label>
        <label>
          Borde redondeado
          <input type="range" id="radius" min="0" max="120" value="16" />
        </label>
        <label>
          Opacidad (%)
          <input type="range" id="opacity" min="10" max="100" value="100" />
        </label>
        <label>
          Z-index
          <input type="range" id="zIndex" min="0" max="20" value="1" />
        </label>
      </div>

      <div class="panel">
        <label>
          Color relleno
          <input type="color" id="fillColor" value="#ef4444" />
        </label>
        <label>
          Color borde
          <input type="color" id="borderColor" value="#e5e7eb" />
        </label>
        <label>
          Alineación texto
          <select id="textAlign">
            <option value="left">Izquierda</option>
            <option value="center" selected>Centro</option>
            <option value="right">Derecha</option>
          </select>
        </label>
      </div>

      <div class="panel ai-figures-tool">
        <label>
          Figura por descripción (IA)
          <textarea id="aiPrompt" class="ai-figures-input" rows="2" placeholder="Ej: copa de vino, espada medieval..."></textarea>
        </label>
        <button id="aiGenerate" class="btn-primary ai-figures-button">Figura con IA</button>
        <div id="aiStatus" class="ai-figures-status"></div>
      </div>
    </div>

    <div class="canvas-frame">
      <div class="canvas" id="canvas"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
    let CANVAS_WIDTH = 820;
    let CANVAS_HEIGHT = 420;
    const MIN_WIDTH = 20;
    const MIN_HEIGHT = 20;

    const canvas = document.getElementById('canvas');
    const addButton = document.getElementById('addElement');
    const toggleTextButton = document.getElementById('toggleText');
    const exportPngButton = document.getElementById('exportPng');
    const exportHtmlButton = document.getElementById('exportHtml');
    const selectedInfo = document.getElementById('selectedInfo');

    const posX = document.getElementById('posX');
    const posY = document.getElementById('posY');
    const sizeW = document.getElementById('sizeW');
    const sizeH = document.getElementById('sizeH');
    const rotate = document.getElementById('rotate');
    const radius = document.getElementById('radius');
    const opacity = document.getElementById('opacity');
    const zIndex = document.getElementById('zIndex');
    const fillColor = document.getElementById('fillColor');
    const borderColor = document.getElementById('borderColor');
    const textAlignSelect = document.getElementById('textAlign');

    const aiPrompt = document.getElementById('aiPrompt');
    const aiGenerateButton = document.getElementById('aiGenerate');
    const aiStatus = document.getElementById('aiStatus');

    const dimX = document.getElementById('dim-x');
    const dimY = document.getElementById('dim-y');
    const dimW = document.getElementById('dim-w');
    const dimH = document.getElementById('dim-h');
    const dimRot = document.getElementById('dim-rot');

    const panelsInputs = document.querySelectorAll('.panel input');

    function updateCanvasMetrics() {
      const rect = canvas.getBoundingClientRect();
      CANVAS_WIDTH = rect.width;
      CANVAS_HEIGHT = rect.height;
      posX.max = Math.max(0, Math.round(CANVAS_WIDTH - MIN_WIDTH));
      posY.max = Math.max(0, Math.round(CANVAS_HEIGHT - MIN_HEIGHT));
    }

    window.addEventListener('resize', updateCanvasMetrics);
    updateCanvasMetrics();

    let elements = [];
    let nextId = 1;
    let selectedIndex = -1;
    let selectedIndices = new Set();
    let dragInfo = null;
    let resizeInfo = null;
    let vertexDragInfo = null;
    let undoStack = [];
    const MAX_HISTORY = 80;

    function clampState(state) {
      const maxX = Math.max(0, CANVAS_WIDTH - state.w);
      const maxY = Math.max(0, CANVAS_HEIGHT - state.h);
      state.x = Math.min(Math.max(0, state.x), maxX);
      state.y = Math.min(Math.max(0, state.y), maxY);
    }

    function applyStateToElement(state) {
      clampState(state);
      const el = state.el;
      el.style.left = state.x + 'px';
      el.style.top = state.y + 'px';
      el.style.width = state.w + 'px';
      el.style.height = state.h + 'px';
      el.style.borderRadius = state.radius + 'px';
      el.style.background = state.fill;
      el.style.borderColor = state.border;
      el.style.opacity = state.opacity / 100;
      el.style.transform = 'rotate(' + state.rotate + 'deg)';
      el.style.zIndex = String(state.z);
    }

    function updateDims(state) {
      if (!state) {
        dimX.textContent = '-';
        dimY.textContent = '-';
        dimW.textContent = '-';
        dimH.textContent = '-';
        dimRot.textContent = '-';
        return;
      }
      dimX.textContent = state.x.toFixed(0);
      dimY.textContent = state.y.toFixed(0);
      dimW.textContent = state.w.toFixed(0);
      dimH.textContent = state.h.toFixed(0);
      dimRot.textContent = state.rotate.toFixed(0);
    }

    function syncControlsFromState(state) {
      posX.value = state.x;
      posY.value = state.y;
      sizeW.value = state.w;
      sizeH.value = state.h;
      rotate.value = state.rotate;
      radius.value = state.radius;
      opacity.value = state.opacity;
      zIndex.value = state.z;
      fillColor.value = state.fill;
      borderColor.value = state.border;
      updateDims(state);
    }

    function setControlsEnabled(enabled) {
      panelsInputs.forEach(input => {
        input.disabled = !enabled;
      });
    }

    function clonePlainState(state) {
      return {
        id: state.id,
        x: state.x,
        y: state.y,
        w: state.w,
        h: state.h,
        rotate: state.rotate,
        radius: state.radius,
        opacity: state.opacity,
        fill: state.fill,
        border: state.border,
        z: state.z,
        isText: !!state.isText,
        text: state.text || '',
        textAlign: state.textAlign || 'center',
        points: state.points
          ? state.points.map((p) => ({ x: p.x, y: p.y }))
          : null,
      };
    }

    function pushHistory() {
      const snapshot = {
        elements: elements.map(clonePlainState),
        selectedId:
          selectedIndex >= 0 && elements[selectedIndex]
            ? elements[selectedIndex].id
            : null,
        nextId,
      };
      undoStack.push(snapshot);
      if (undoStack.length > MAX_HISTORY) {
        undoStack.shift();
      }
    }

    function clearAllElements() {
      elements.forEach((state) => {
        if (state.el && state.el.parentNode) {
          state.el.parentNode.removeChild(state.el);
        }
        if (state.resizeEls) {
          state.resizeEls.forEach((h) => h.remove());
        }
        if (state.vertexEls) {
          state.vertexEls.forEach((h) => h.remove());
        }
      });
      elements = [];
      selectedIndex = -1;
      selectedIndices = new Set();
      updateDims(null);
      setControlsEnabled(false);
      selectedInfo.textContent = 'Sin elemento seleccionado';
    }

    function restoreFromSnapshot(snapshot) {
      if (!snapshot) return;
      clearAllElements();
      nextId = snapshot.nextId || 1;

      snapshot.elements.forEach((data) => {
        const el = document.createElement('div');
        el.className = 'shape';
        const state = {
          id: data.id,
          el,
          x: data.x,
          y: data.y,
          w: data.w,
          h: data.h,
          rotate: data.rotate,
          radius: data.radius,
          opacity: data.opacity,
          fill: data.fill,
          border: data.border,
          z: data.z,
          points: data.points
            ? data.points.map((p) => ({ x: p.x, y: p.y }))
            : null,
          resizeEls: [],
          vertexEls: [],
        };
        elements.push(state);
        canvas.appendChild(el);

        ensurePolygonState(state);
      if (data.isText) {
        state.isText = true;
        state.text = data.text || '';
        state.textAlign = data.textAlign || 'center';
        ensureTextElement(state);
      }
        if (data.points && data.points.length >= 3) {
          state.points = data.points.map((p) => ({ x: p.x, y: p.y }));
        }

        const dirs = ['nw', 'ne', 'se', 'sw'];
        state.resizeEls = [];
        dirs.forEach((dir) => {
          const h = document.createElement('div');
          h.className = 'resize-handle resize-' + dir;
          h.dataset.dir = dir;
          h.addEventListener('pointerdown', (ev) => {
            const idx = elements.indexOf(state);
            if (idx !== -1) {
              startResize(ev, idx, dir);
            }
          });
          el.appendChild(h);
          state.resizeEls.push(h);
        });

        updateClipPath(state);
        rebuildVertexHandles(state);
        applyStateToElement(state);

        el.addEventListener('pointerdown', (ev) => {
          const target = ev.target;
          if (
            target.classList &&
            (target.classList.contains('resize-handle') ||
              target.classList.contains('vertex-handle') ||
              target.classList.contains('shape-text'))
          ) {
            return;
          }
          const idx = elements.indexOf(state);
          if (idx !== -1) {
            const additive = ev.ctrlKey || ev.metaKey;
            selectElementWithCtrl(idx, additive);
            startDrag(ev, idx);
          }
        });

        el.addEventListener('dblclick', (ev) => {
          const idx = elements.indexOf(state);
          if (idx !== -1) {
            addVertexAtEvent(ev, idx);
          }
        });
      });

      if (snapshot.selectedId != null) {
        const idx = elements.findIndex((e) => e.id === snapshot.selectedId);
        if (idx !== -1) {
          selectElement(idx);
        } else {
          selectElement(-1);
        }
      } else {
        selectElement(-1);
      }
    }

    function selectElement(index) {
      // Limpieza previa
      if (index === -1 || !elements[index]) {
        selectedIndices.forEach((idx) => {
          if (elements[idx]) {
            elements[idx].el.classList.remove('is-selected');
          }
        });
        selectedIndices = new Set();
        selectedIndex = -1;
        selectedInfo.textContent = 'Sin elemento seleccionado';
        setControlsEnabled(false);
        updateDims(null);
        return;
      }

      selectedIndices.forEach((idx) => {
        if (elements[idx]) {
          elements[idx].el.classList.remove('is-selected');
        }
      });
      selectedIndices = new Set([index]);
      selectedIndex = index;

      const state = elements[index];
      state.el.classList.add('is-selected');
      selectedInfo.textContent = 'Elemento #' + state.id;
      setControlsEnabled(true);
      syncControlsFromState(state);
    }

    function selectElementWithCtrl(index, additive) {
      if (index < 0 || !elements[index]) {
        selectElement(-1);
        return;
      }

      if (!additive) {
        selectElement(index);
        return;
      }

      if (selectedIndices.has(index)) {
        // Quitar de la selección
        elements[index].el.classList.remove('is-selected');
        selectedIndices.delete(index);
        if (index === selectedIndex) {
          if (selectedIndices.size > 0) {
            const first = [...selectedIndices][0];
            selectedIndex = first;
            syncControlsFromState(elements[first]);
          } else {
            selectElement(-1);
          }
        }
      } else {
        selectedIndices.add(index);
        selectedIndex = index;
        elements[index].el.classList.add('is-selected');
        syncControlsFromState(elements[index]);
      }

      if (selectedIndex !== -1 && elements[selectedIndex]) {
        const primary = elements[selectedIndex];
        const extra = Math.max(0, selectedIndices.size - 1);
        selectedInfo.textContent = extra
          ? `Elemento #${primary.id} (+${extra})`
          : `Elemento #${primary.id}`;
        setControlsEnabled(true);
      }
    }

    function ensurePolygonState(state) {
      if (state.points && state.points.length >= 3) return;
      state.points = [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 1, y: 1 },
        { x: 0, y: 1 },
      ];
      state.vertexEls = [];
      updateClipPath(state);
      rebuildVertexHandles(state);
    }

    function autoSizeTextShape(state) {
      if (!state.isText || !state.textEl) return;
      const t = state.textEl;
      const contentHeight = t.scrollHeight;
      const neededH = Math.ceil(contentHeight + 12);

      if (!Number.isFinite(neededH)) return;

      state.h = Math.max(MIN_HEIGHT, neededH);
      applyStateToElement(state);
      updateClipPath(state);
      updateVertexHandlePositions(state);
      syncControlsFromState(state);
    }

    function ensureTextElement(state) {
      if (!state.isText) return;
      if (!state.textEl) {
        const t = document.createElement('div');
        t.className = 'shape-text';
        t.contentEditable = 'true';
        t.spellcheck = false;
        t.textContent = state.text || '';
        state.el.appendChild(t);
        state.textEl = t;
        t.addEventListener('input', () => {
          state.text = t.textContent || '';
          autoSizeTextShape(state);
        });
      }
      const align = state.textAlign || 'center';
      state.textEl.style.textAlign = align;
      if (align === 'left') {
        state.textEl.style.justifyContent = 'flex-start';
      } else if (align === 'right') {
        state.textEl.style.justifyContent = 'flex-end';
      } else {
        state.textEl.style.justifyContent = 'center';
      }
    }

    function updateClipPath(state) {
      if (!state.points || state.points.length < 3) {
        state.el.style.clipPath = '';
        return;
      }
      const pointsStr = state.points
        .map((p) => (p.x * 100).toFixed(1) + '% ' + (p.y * 100).toFixed(1) + '%')
        .join(', ');
      state.el.style.clipPath = 'polygon(' + pointsStr + ')';
      ensureTextElement(state);
    }

    function updateVertexHandlePositions(state) {
      if (!state.points || !state.vertexEls) return;
      state.points.forEach((p, i) => {
        const h = state.vertexEls[i];
        if (!h) return;
        const worldX = state.x + p.x * state.w;
        const worldY = state.y + p.y * state.h;
        h.style.left = worldX + 'px';
        h.style.top = worldY + 'px';
      });
    }

    function rebuildVertexHandles(state) {
      if (state.vertexEls) {
        state.vertexEls.forEach((h) => h.remove());
      }
      state.vertexEls = [];
      if (!state.points || state.points.length < 3) return;

      const stateIndex = elements.indexOf(state);
      state.points.forEach((p, i) => {
        const h = document.createElement('div');
        h.className = 'vertex-handle';
        h.dataset.index = String(i);
        h.addEventListener('pointerdown', (ev) => {
          if (ev.detail > 1) return;
          const idx = elements.indexOf(state);
          if (idx !== -1) {
            startVertexDrag(ev, idx, i);
          }
        });
        h.addEventListener('dblclick', (ev) => {
          const idx = elements.indexOf(state);
          if (idx !== -1) {
            removeVertexAtIndex(ev, idx, i);
          }
        });
        canvas.appendChild(h);
        state.vertexEls.push(h);
      });
      updateVertexHandlePositions(state);
    }

    function expandBoundsToFitPoints(state) {
      if (!state.points || state.points.length === 0) return;

      const pts = state.points;
      let minX = pts[0].x, maxX = pts[0].x;
      let minY = pts[0].y, maxY = pts[0].y;

      for (let i = 1; i < pts.length; i++) {
        const p = pts[i];
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }

      const oldX = state.x;
      const oldY = state.y;
      const oldW = state.w;
      const oldH = state.h;

      const worldMinX = oldX + minX * oldW;
      const worldMaxX = oldX + maxX * oldW;
      const worldMinY = oldY + minY * oldH;
      const worldMaxY = oldY + maxY * oldH;

      const newW = Math.max(MIN_WIDTH, worldMaxX - worldMinX);
      const newH = Math.max(MIN_HEIGHT, worldMaxY - worldMinY);

      const spanX = maxX - minX || 1;
      const spanY = maxY - minY || 1;

      state.x = worldMinX;
      state.y = worldMinY;
      state.w = newW;
      state.h = newH;

      pts.forEach((p) => {
        p.x = (p.x - minX) / spanX;
        p.y = (p.y - minY) / spanY;
      });
    }

    function removeVertexAtIndex(ev, stateIndex, pointIndex) {
      if (stateIndex < 0 || !elements[stateIndex]) return;
      ev.preventDefault();
      ev.stopPropagation();

      const state = elements[stateIndex];
      if (!state.points || state.points.length <= 3) {
        return;
      }

      pushHistory();
      state.points.splice(pointIndex, 1);

      expandBoundsToFitPoints(state);
      applyStateToElement(state);
      updateClipPath(state);
      rebuildVertexHandles(state);
      syncControlsFromState(state);
    }

    function distancePointToSegment(px, py, a, b) {
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = px - a.x;
      const wy = py - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return Math.hypot(px - a.x, py - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return Math.hypot(px - b.x, py - b.y);
      const t = c1 / c2;
      const projx = a.x + t * vx;
      const projy = a.y + t * vy;
      return Math.hypot(px - projx, py - projy);
    }

    function addVertexAtEvent(ev, index) {
      if (index < 0 || !elements[index]) return;
      ev.preventDefault();
      ev.stopPropagation();

      pushHistory();
      const state = elements[index];
      ensurePolygonState(state);

      const rect = state.el.getBoundingClientRect();
      const localX = ev.clientX - rect.left;
      const localY = ev.clientY - rect.top;
      const nx = localX / rect.width;
      const ny = localY / rect.height;

      const pts = state.points;
      if (pts.length < 3) {
        pts.push({ x: nx, y: ny });
      } else {
        let bestIdx = 0;
        let bestDist = Infinity;
        for (let i = 0; i < pts.length; i++) {
          const a = pts[i];
          const b = pts[(i + 1) % pts.length];
          const d = distancePointToSegment(nx, ny, a, b);
          if (d < bestDist) {
            bestDist = d;
            bestIdx = i + 1;
          }
        }
        pts.splice(bestIdx, 0, { x: nx, y: ny });
      }

      expandBoundsToFitPoints(state);
      applyStateToElement(state);
      updateClipPath(state);
      rebuildVertexHandles(state);
      syncControlsFromState(state);
    }

    function startDrag(ev, index) {
      if (index < 0 || !elements[index]) return;
      ev.preventDefault();
      ev.stopPropagation();

      pushHistory();

      const rect = canvas.getBoundingClientRect();
      const pointerX = ev.clientX - rect.left;
      const pointerY = ev.clientY - rect.top;

      const indices = selectedIndices.size > 0 ? [...selectedIndices] : [index];

      dragInfo = {
        startPointerX: pointerX,
        startPointerY: pointerY,
        items: indices.map((idx) => ({
          index: idx,
          startX: elements[idx].x,
          startY: elements[idx].y,
        })),
      };

      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp);
      window.addEventListener('pointercancel', handlePointerUp);
    }

    function startResize(ev, index, dir) {
      if (index < 0 || !elements[index]) return;
      ev.preventDefault();
      ev.stopPropagation();

      pushHistory();
      const state = elements[index];
      selectElement(index);

      resizeInfo = {
        index,
        dir,
        startW: state.w,
        startH: state.h,
        startX: state.x,
        startY: state.y,
        startPointerX: ev.clientX,
        startPointerY: ev.clientY,
      };

      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp);
      window.addEventListener('pointercancel', handlePointerUp);
    }

    function startVertexDrag(ev, index, pointIndex) {
      if (index < 0 || !elements[index]) return;
      ev.preventDefault();
      ev.stopPropagation();

      pushHistory();
      const state = elements[index];
      ensurePolygonState(state);
      selectElement(index);

      vertexDragInfo = {
        index,
        pointIndex,
      };

      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp);
      window.addEventListener('pointercancel', handlePointerUp);
    }

    function handlePointerMove(ev) {
      if (vertexDragInfo && vertexDragInfo.index >= 0 && elements[vertexDragInfo.index]) {
        const state = elements[vertexDragInfo.index];
        const rect = state.el.getBoundingClientRect();
        const localX = ev.clientX - rect.left;
        const localY = ev.clientY - rect.top;
        const nx = localX / rect.width;
        const ny = localY / rect.height;
        if (state.points && state.points[vertexDragInfo.pointIndex]) {
          state.points[vertexDragInfo.pointIndex].x = nx;
          state.points[vertexDragInfo.pointIndex].y = ny;
          expandBoundsToFitPoints(state);
          applyStateToElement(state);
          updateClipPath(state);
          updateVertexHandlePositions(state);
          syncControlsFromState(state);
        }
        return;
      }

      if (resizeInfo && resizeInfo.index >= 0 && elements[resizeInfo.index]) {
        const state = elements[resizeInfo.index];
        const dx = ev.clientX - resizeInfo.startPointerX;
        const dy = ev.clientY - resizeInfo.startPointerY;
        let newW = resizeInfo.startW;
        let newH = resizeInfo.startH;
        let newX = resizeInfo.startX;
        let newY = resizeInfo.startY;

        if (resizeInfo.dir.indexOf('e') !== -1) {
          newW = resizeInfo.startW + dx;
        }
        if (resizeInfo.dir.indexOf('s') !== -1) {
          newH = resizeInfo.startH + dy;
        }
        if (resizeInfo.dir.indexOf('w') !== -1) {
          newW = resizeInfo.startW - dx;
          newX = resizeInfo.startX + dx;
        }
        if (resizeInfo.dir.indexOf('n') !== -1) {
          newH = resizeInfo.startH - dy;
          newY = resizeInfo.startY + dy;
        }

        newW = Math.max(MIN_WIDTH, newW);
        newH = Math.max(MIN_HEIGHT, newH);

        state.w = newW;
        state.h = newH;
        state.x = newX;
        state.y = newY;

        applyStateToElement(state);
        syncControlsFromState(state);
        updateVertexHandlePositions(state);
        return;
      }

      if (!dragInfo || !dragInfo.items || dragInfo.items.length === 0) return;
      const rect = canvas.getBoundingClientRect();
      const pointerX = ev.clientX - rect.left;
      const pointerY = ev.clientY - rect.top;
      const dx = pointerX - dragInfo.startPointerX;
      const dy = pointerY - dragInfo.startPointerY;

      dragInfo.items.forEach((item) => {
        const st = elements[item.index];
        if (!st) return;
        st.x = item.startX + dx;
        st.y = item.startY + dy;
        applyStateToElement(st);
        updateVertexHandlePositions(st);
      });

      if (selectedIndex !== -1 && elements[selectedIndex]) {
        syncControlsFromState(elements[selectedIndex]);
      }
    }

    function handlePointerUp(ev) {
      if (vertexDragInfo) {
        ev.preventDefault();
        ev.stopPropagation();
        const state = elements[vertexDragInfo.index];
        if (state) {
          expandBoundsToFitPoints(state);
          applyStateToElement(state);
          updateClipPath(state);
          updateVertexHandlePositions(state);
          syncControlsFromState(state);
        }
        vertexDragInfo = null;
      } else if (resizeInfo) {
        ev.preventDefault();
        ev.stopPropagation();
        resizeInfo = null;
      } else if (dragInfo && dragInfo.items && dragInfo.items.length > 0) {
        ev.preventDefault();
        ev.stopPropagation();
        dragInfo = null;
      } else {
        dragInfo = null;
      }

      window.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('pointerup', handlePointerUp);
      window.removeEventListener('pointercancel', handlePointerUp);
    }

    function createElement() {
      const el = document.createElement('div');
      el.className = 'shape';

      const state = {
        id: nextId++,
        el,
        x: 340,
        y: 150,
        w: 120,
        h: 80,
        rotate: 0,
        radius: 16,
        opacity: 100,
        fill: '#ef4444',
        border: '#e5e7eb',
        z: elements.length + 1,
        isText: false,
        text: '',
        textAlign: 'center',
        textEl: null,
      };

      elements.push(state);
      canvas.appendChild(el);

      ensurePolygonState(state);

      const dirs = ['nw', 'ne', 'se', 'sw'];
      state.resizeEls = [];
      dirs.forEach((dir) => {
        const h = document.createElement('div');
        h.className = 'resize-handle resize-' + dir;
        h.dataset.dir = dir;
        h.addEventListener('pointerdown', (ev) => {
          const idx = elements.indexOf(state);
          if (idx !== -1) {
            startResize(ev, idx, dir);
          }
        });
        el.appendChild(h);
        state.resizeEls.push(h);
      });

      updateClipPath(state);
      rebuildVertexHandles(state);
      applyStateToElement(state);

      el.addEventListener('pointerdown', (ev) => {
        const target = ev.target;
        if (
          target.classList &&
          (target.classList.contains('resize-handle') ||
            target.classList.contains('vertex-handle') ||
            target.classList.contains('shape-text'))
        ) {
          return;
        }
        const idx = elements.indexOf(state);
        if (idx !== -1) {
          const additive = ev.ctrlKey || ev.metaKey;
          selectElementWithCtrl(idx, additive);
          startDrag(ev, idx);
        }
      });

      el.addEventListener('dblclick', (ev) => {
        const idx = elements.indexOf(state);
        if (idx !== -1) {
          addVertexAtEvent(ev, idx);
        }
      });

      selectElement(elements.length - 1);
    }

    function updateFromControls() {
      if (selectedIndex === -1) return;
      const state = elements[selectedIndex];
      pushHistory();
      state.x = Number(posX.value);
      state.y = Number(posY.value);
      state.w = Number(sizeW.value);
      state.h = Number(sizeH.value);
      state.rotate = Number(rotate.value);
      state.radius = Number(radius.value);
      state.opacity = Number(opacity.value);
      state.z = Number(zIndex.value);
      state.fill = fillColor.value;
      state.border = borderColor.value;
      applyStateToElement(state);
      syncControlsFromState(state);
    }

    addButton.addEventListener('click', () => {
      pushHistory();
      createElement();
    });

    canvas.addEventListener('click', (ev) => {
      if (ev.target === canvas) {
        selectElement(-1);
      }
    });

    [posX, posY, sizeW, sizeH, rotate, radius, opacity, zIndex].forEach(input => {
      input.addEventListener('input', updateFromControls);
    });

    [fillColor, borderColor].forEach(input => {
      input.addEventListener('input', updateFromControls);
    });

    textAlignSelect.addEventListener('change', () => {
      if (selectedIndex === -1 || !elements[selectedIndex]) return;
      const state = elements[selectedIndex];
      if (!state.isText) return;
      pushHistory();
      state.textAlign = textAlignSelect.value;
      ensureTextElement(state);
    });

    function deleteSelectedElement() {
      if (!elements.length || selectedIndices.size === 0) return;
      pushHistory();

      const indices = [...selectedIndices].sort((a, b) => b - a);
      indices.forEach((idx) => {
        if (!elements[idx]) return;
        const st = elements[idx];
        if (st.el) st.el.remove();
        if (st.resizeEls) st.resizeEls.forEach((h) => h.remove());
        if (st.vertexEls) st.vertexEls.forEach((h) => h.remove());
        elements.splice(idx, 1);
      });

      if (elements.length === 0) {
        selectedIndex = -1;
        selectedIndices = new Set();
        selectedInfo.textContent = 'Sin elemento seleccionado';
        setControlsEnabled(false);
        updateDims(null);
      } else {
        const newIndex = Math.min(Math.min(...indices), elements.length - 1);
        selectElement(newIndex);
      }
    }

    window.addEventListener('keydown', (ev) => {
      const key = ev.key;

      if ((key === 'Delete' || key === 'Backspace') && selectedIndex !== -1) {
        ev.preventDefault();
        deleteSelectedElement();
        return;
      }

      const isUndo = (key === 'z' || key === 'Z') && (ev.ctrlKey || ev.metaKey);
      if (isUndo) {
        ev.preventDefault();
        const snapshot = undoStack.pop();
        if (snapshot) {
          restoreFromSnapshot(snapshot);
        }
      }
    });

    toggleTextButton.addEventListener('click', () => {
      if (selectedIndex === -1 || !elements[selectedIndex]) return;
      const state = elements[selectedIndex];
      pushHistory();
      state.isText = !state.isText;
      if (state.isText) {
        state.textAlign = state.textAlign || 'center';
        if (!state.text || state.text.trim() === '') {
          state.text = '';
        } else if (state.textEl) {
          state.text = state.textEl.textContent || '';
        }
        ensureTextElement(state);
        textAlignSelect.value = state.textAlign;
        if (state.textEl) {
          state.textEl.focus();
          autoSizeTextShape(state);
        }
      } else {
        if (state.textEl) {
          state.text = state.textEl.textContent || '';
          state.textEl.remove();
          state.textEl = null;
        }
      }
    });

    function escapeHtml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function buildTextAlignExport(align) {
      if (align === 'left') return 'justify-content:flex-start;';
      if (align === 'right') return 'justify-content:flex-end;';
      return 'justify-content:center;';
    }

    exportPngButton.addEventListener('click', async () => {
      if (!window.html2canvas) {
        alert('No se pudo cargar la librería de captura (html2canvas).');
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const scale = window.devicePixelRatio || 1;
      const imgCanvas = await window.html2canvas(canvas, {
        backgroundColor: '#020617',
        width: rect.width,
        height: rect.height,
        scale,
      });
      imgCanvas.toBlob((blob) => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'lienzo.png';
        a.click();
        URL.revokeObjectURL(url);
      });
    });

    exportHtmlButton.addEventListener('click', () => {
      const rect = canvas.getBoundingClientRect();
      const width = Math.round(rect.width);
      const height = Math.round(rect.height);

      const shapesHtml = elements.map((state) => {
        const styles = [];
        styles.push('left:' + state.x + 'px;');
        styles.push('top:' + state.y + 'px;');
        styles.push('width:' + state.w + 'px;');
        styles.push('height:' + state.h + 'px;');
        styles.push('border-radius:' + state.radius + 'px;');
        styles.push('background:' + state.fill + ';');
        styles.push('opacity:' + state.opacity / 100 + ';');
        styles.push('transform:rotate(' + state.rotate + 'deg);');
        styles.push('z-index:' + state.z + ';');
        if (state.el && state.el.style.clipPath) {
          styles.push('clip-path:' + state.el.style.clipPath + ';');
        }

        let inner = '';
        if (state.isText) {
          const align = state.textAlign || 'center';
          const content = state.textEl
            ? state.textEl.textContent || ''
            : state.text || '';
          const extra = buildTextAlignExport(align);
          inner = '<div class="shape-text" style="text-align:' + align + ';' + extra + '">' + escapeHtml(content) + '</div>';
        }

        return '<div class="shape" style="' + styles.join('') + '">' + inner + '</div>';
      }).join('');

      const css = [
        'body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;background:#020617;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;}',
        '.canvas-export{position:relative;width:' + width + 'px;height:' + height + 'px;border-radius:14px;background:radial-gradient(circle at 20% 0%,#1e293b,#020617 60%,#000 100%);overflow:hidden;box-shadow:inset 0 0 0 1px rgba(15,23,42,0.9),0 10px 30px rgba(0,0,0,0.8);}',
        '.shape{position:absolute;border-radius:16px;box-shadow:0 0 0 1px rgba(15,23,42,0.95),0 10px 22px rgba(0,0,0,0.8);}',
        '.shape::before{content:"";position:absolute;inset:0;border:2px solid #e5e7eb;border-radius:inherit;pointer-events:none;clip-path:inherit;}',
        '.shape-text{position:absolute;inset:6px;padding:4px 6px;color:#f9fafb;font-size:13px;line-height:1.3;display:flex;align-items:center;justify-content:center;white-space:pre-wrap;}'
      ].join('');

      const html =
        '<!DOCTYPE html>' +
        '<html lang="es"><head><meta charset="utf-8" /><title>Exportación lienzo</title><style>' +
        css +
        '</style></head><body><div class="canvas-export">' +
        shapesHtml +
        '</div></body></html>';

      const blob = new Blob([html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'lienzo.html';
      a.click();
      URL.revokeObjectURL(url);
    });

    function createElementFromCss(css) {
      if (!css) return;
      pushHistory();
      createElement();
      const state = elements[elements.length - 1];
      if (!state) return;

      const bgMatch = css.match(/background(?:-color)?\s*:\s*([^;]+);/i);
      if (bgMatch) {
        state.fill = bgMatch[1].trim();
      }

      const borderMatch = css.match(/border(?:-color)?\s*:\s*([^;]+);/i);
      if (borderMatch) {
        state.border = borderMatch[1].trim();
      }

      const clipMatch = css.match(/clip-path\s*:\s*polygon\s*\(([^)]+)\)/i);
      if (clipMatch) {
        const rawPoints = clipMatch[1].split(',');
        const pts = [];
        rawPoints.forEach((part) => {
          const m = part.trim().match(/^([0-9.]+)%\s+([0-9.]+)%$/);
          if (m) {
            pts.push({ x: parseFloat(m[1]) / 100, y: parseFloat(m[2]) / 100 });
          }
        });
        if (pts.length >= 3) {
          state.points = pts;
        }
      }

      applyStateToElement(state);
      updateClipPath(state);
      rebuildVertexHandles(state);
      selectElement(elements.length - 1);
    }

    function setupAIFigures() {
      if (!aiPrompt || !aiGenerateButton || !aiStatus) return;

      async function generateFigure() {
        const texto = (aiPrompt.value || '').trim();
        if (!texto) {
          aiStatus.textContent = 'Escribe una descripción primero.';
          return;
        }

        aiStatus.textContent = 'Generando figura con IA...';
        aiGenerateButton.disabled = true;

        try {
          const resp = await fetch('http://localhost:5050/api/gemini-figura', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ figura: texto })
          });

          if (!resp.ok) {
            aiStatus.textContent = 'Error del servidor (' + resp.status + ').';
            return;
          }

          const data = await resp.json();
          if (data && data.css) {
            createElementFromCss(data.css);
            aiStatus.textContent = 'Figura creada en el lienzo.';
          } else if (data && data.error) {
            aiStatus.textContent = data.error;
          } else {
            aiStatus.textContent = 'No se recibió CSS válido.';
          }
        } catch (e) {
          aiStatus.textContent = 'Error al conectar con el generador.';
        } finally {
          aiGenerateButton.disabled = false;
        }
      }

      aiGenerateButton.addEventListener('click', generateFigure);
      aiPrompt.addEventListener('keydown', function (ev) {
        if (ev.key === 'Enter' && (ev.ctrlKey || ev.metaKey)) {
          ev.preventDefault();
          generateFigure();
        }
      });
    }

    setupAIFigures();

    // Al inicio, sin elemento seleccionado
    setControlsEnabled(false);
    updateDims(null);
  </script>
</body>
</html>
